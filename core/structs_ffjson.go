// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: structs.go
// DO NOT EDIT!

package bots

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
	"github.com/strongo/bots-api-fbm"
	"github.com/strongo/bots-api-telegram"
	"github.com/strongo/bots-api-viber/viberinterface"
)

func (mj *BaseHandler) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *BaseHandler) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"WebhookDriver":`)
	/* Interface types must use runtime reflection. type=bots.WebhookDriver kind=interface */
	err = buf.Encode(mj.WebhookDriver)
	if err != nil {
		return err
	}
	buf.WriteString(`,"BotHost":`)
	/* Interface types must use runtime reflection. type=bots.BotHost kind=interface */
	err = buf.Encode(mj.BotHost)
	if err != nil {
		return err
	}
	buf.WriteString(`,"BotPlatform":`)
	/* Interface types must use runtime reflection. type=bots.BotPlatform kind=interface */
	err = buf.Encode(mj.BotPlatform)
	if err != nil {
		return err
	}
	buf.WriteString(`,"TranslatorProvider":`)
	/* Falling back. type=bots.TranslatorProvider kind=func */
	err = buf.Encode(mj.TranslatorProvider)
	if err != nil {
		return err
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_BaseHandlerbase = iota
	ffj_t_BaseHandlerno_such_key

	ffj_t_BaseHandler_WebhookDriver

	ffj_t_BaseHandler_BotHost

	ffj_t_BaseHandler_BotPlatform

	ffj_t_BaseHandler_TranslatorProvider
)

var ffj_key_BaseHandler_WebhookDriver = []byte("WebhookDriver")

var ffj_key_BaseHandler_BotHost = []byte("BotHost")

var ffj_key_BaseHandler_BotPlatform = []byte("BotPlatform")

var ffj_key_BaseHandler_TranslatorProvider = []byte("TranslatorProvider")

func (uj *BaseHandler) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *BaseHandler) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_BaseHandlerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_BaseHandlerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'B':

					if bytes.Equal(ffj_key_BaseHandler_BotHost, kn) {
						currentKey = ffj_t_BaseHandler_BotHost
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_BaseHandler_BotPlatform, kn) {
						currentKey = ffj_t_BaseHandler_BotPlatform
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffj_key_BaseHandler_TranslatorProvider, kn) {
						currentKey = ffj_t_BaseHandler_TranslatorProvider
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'W':

					if bytes.Equal(ffj_key_BaseHandler_WebhookDriver, kn) {
						currentKey = ffj_t_BaseHandler_WebhookDriver
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_BaseHandler_TranslatorProvider, kn) {
					currentKey = ffj_t_BaseHandler_TranslatorProvider
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_BaseHandler_BotPlatform, kn) {
					currentKey = ffj_t_BaseHandler_BotPlatform
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_BaseHandler_BotHost, kn) {
					currentKey = ffj_t_BaseHandler_BotHost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_BaseHandler_WebhookDriver, kn) {
					currentKey = ffj_t_BaseHandler_WebhookDriver
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_BaseHandlerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_BaseHandler_WebhookDriver:
					goto handle_WebhookDriver

				case ffj_t_BaseHandler_BotHost:
					goto handle_BotHost

				case ffj_t_BaseHandler_BotPlatform:
					goto handle_BotPlatform

				case ffj_t_BaseHandler_TranslatorProvider:
					goto handle_TranslatorProvider

				case ffj_t_BaseHandlerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_WebhookDriver:

	/* handler: uj.WebhookDriver type=bots.WebhookDriver kind=interface quoted=false*/

	{
		/* Falling back. type=bots.WebhookDriver kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.WebhookDriver)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BotHost:

	/* handler: uj.BotHost type=bots.BotHost kind=interface quoted=false*/

	{
		/* Falling back. type=bots.BotHost kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.BotHost)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BotPlatform:

	/* handler: uj.BotPlatform type=bots.BotPlatform kind=interface quoted=false*/

	{
		/* Falling back. type=bots.BotPlatform kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.BotPlatform)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TranslatorProvider:

	/* handler: uj.TranslatorProvider type=bots.TranslatorProvider kind=func quoted=false*/

	{
		/* Falling back. type=bots.TranslatorProvider kind=func */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.TranslatorProvider)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *EntryInput) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EntryInput) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Entry":`)
	/* Interface types must use runtime reflection. type=bots.WebhookEntry kind=interface */
	err = buf.Encode(mj.Entry)
	if err != nil {
		return err
	}
	buf.WriteString(`,"Input":`)
	/* Interface types must use runtime reflection. type=bots.WebhookInput kind=interface */
	err = buf.Encode(mj.Input)
	if err != nil {
		return err
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EntryInputbase = iota
	ffj_t_EntryInputno_such_key

	ffj_t_EntryInput_Entry

	ffj_t_EntryInput_Input
)

var ffj_key_EntryInput_Entry = []byte("Entry")

var ffj_key_EntryInput_Input = []byte("Input")

func (uj *EntryInput) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EntryInput) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EntryInputbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EntryInputno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'E':

					if bytes.Equal(ffj_key_EntryInput_Entry, kn) {
						currentKey = ffj_t_EntryInput_Entry
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'I':

					if bytes.Equal(ffj_key_EntryInput_Input, kn) {
						currentKey = ffj_t_EntryInput_Input
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_EntryInput_Input, kn) {
					currentKey = ffj_t_EntryInput_Input
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EntryInput_Entry, kn) {
					currentKey = ffj_t_EntryInput_Entry
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EntryInputno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EntryInput_Entry:
					goto handle_Entry

				case ffj_t_EntryInput_Input:
					goto handle_Input

				case ffj_t_EntryInputno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Entry:

	/* handler: uj.Entry type=bots.WebhookEntry kind=interface quoted=false*/

	{
		/* Falling back. type=bots.WebhookEntry kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Entry)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Input:

	/* handler: uj.Input type=bots.WebhookInput kind=interface quoted=false*/

	{
		/* Falling back. type=bots.WebhookInput kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Input)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *EntryInputs) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EntryInputs) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Entry":`)
	/* Interface types must use runtime reflection. type=bots.WebhookEntry kind=interface */
	err = buf.Encode(mj.Entry)
	if err != nil {
		return err
	}
	buf.WriteString(`,"Inputs":`)
	if mj.Inputs != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Inputs {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Interface types must use runtime reflection. type=bots.WebhookInput kind=interface */
			err = buf.Encode(v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EntryInputsbase = iota
	ffj_t_EntryInputsno_such_key

	ffj_t_EntryInputs_Entry

	ffj_t_EntryInputs_Inputs
)

var ffj_key_EntryInputs_Entry = []byte("Entry")

var ffj_key_EntryInputs_Inputs = []byte("Inputs")

func (uj *EntryInputs) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EntryInputs) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EntryInputsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EntryInputsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'E':

					if bytes.Equal(ffj_key_EntryInputs_Entry, kn) {
						currentKey = ffj_t_EntryInputs_Entry
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'I':

					if bytes.Equal(ffj_key_EntryInputs_Inputs, kn) {
						currentKey = ffj_t_EntryInputs_Inputs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_EntryInputs_Inputs, kn) {
					currentKey = ffj_t_EntryInputs_Inputs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EntryInputs_Entry, kn) {
					currentKey = ffj_t_EntryInputs_Entry
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EntryInputsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EntryInputs_Entry:
					goto handle_Entry

				case ffj_t_EntryInputs_Inputs:
					goto handle_Inputs

				case ffj_t_EntryInputsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Entry:

	/* handler: uj.Entry type=bots.WebhookEntry kind=interface quoted=false*/

	{
		/* Falling back. type=bots.WebhookEntry kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Entry)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Inputs:

	/* handler: uj.Inputs type=[]bots.WebhookInput kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Inputs = nil
		} else {

			uj.Inputs = []WebhookInput{}

			wantVal := true

			for {

				var tmp_uj__Inputs WebhookInput

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Inputs type=bots.WebhookInput kind=interface quoted=false*/

				{
					/* Falling back. type=bots.WebhookInput kind=interface */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmp_uj__Inputs)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				uj.Inputs = append(uj.Inputs, tmp_uj__Inputs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *MessageFromBot) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MessageFromBot) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Text) != 0 {
		buf.WriteString(`"Text":`)
		fflib.WriteJsonString(buf, string(mj.Text))
		buf.WriteByte(',')
	}
	if mj.Format != 0 {
		buf.WriteString(`"Format":`)
		fflib.FormatBits2(buf, uint64(mj.Format), 10, mj.Format < 0)
		buf.WriteByte(',')
	}
	if mj.DisableWebPagePreview != false {
		if mj.DisableWebPagePreview {
			buf.WriteString(`"DisableWebPagePreview":true`)
		} else {
			buf.WriteString(`"DisableWebPagePreview":false`)
		}
		buf.WriteByte(',')
	}
	if mj.DisableNotification != false {
		if mj.DisableNotification {
			buf.WriteString(`"DisableNotification":true`)
		} else {
			buf.WriteString(`"DisableNotification":false`)
		}
		buf.WriteByte(',')
	}
	if mj.TelegramKeyboard != nil {
		buf.WriteString(`"TelegramKeyboard":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(mj.TelegramKeyboard)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if mj.ViberKeyboard != nil {
		if true {
			buf.WriteString(`"ViberKeyboard":`)

			{

				err = mj.ViberKeyboard.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.FbmAttachment != nil {
		if true {
			buf.WriteString(`"FbmAttachment":`)

			{

				err = mj.FbmAttachment.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.TelegramInlineConfig != nil {
		if true {
			buf.WriteString(`"TelegramInlineConfig":`)

			{

				err = mj.TelegramInlineConfig.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.TelegramCallbackAnswer != nil {
		if true {
			buf.WriteString(`"TelegramCallbackAnswer":`)

			{

				err = mj.TelegramCallbackAnswer.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.TelegramEditMessageText != nil {
		if true {
			buf.WriteString(`"TelegramEditMessageText":`)

			{

				err = mj.TelegramEditMessageText.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.TelegramEditMessageMarkup != nil {
		if true {
			buf.WriteString(`"TelegramEditMessageMarkup":`)

			{

				err = mj.TelegramEditMessageMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.TelegramChatID != 0 {
		buf.WriteString(`"TelegramChatID":`)
		fflib.FormatBits2(buf, uint64(mj.TelegramChatID), 10, mj.TelegramChatID < 0)
		buf.WriteByte(',')
	}
	if mj.IsReplyToInputMessage != false {
		if mj.IsReplyToInputMessage {
			buf.WriteString(`"IsReplyToInputMessage":true`)
		} else {
			buf.WriteString(`"IsReplyToInputMessage":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MessageFromBotbase = iota
	ffj_t_MessageFromBotno_such_key

	ffj_t_MessageFromBot_Text

	ffj_t_MessageFromBot_Format

	ffj_t_MessageFromBot_DisableWebPagePreview

	ffj_t_MessageFromBot_DisableNotification

	ffj_t_MessageFromBot_TelegramKeyboard

	ffj_t_MessageFromBot_ViberKeyboard

	ffj_t_MessageFromBot_FbmAttachment

	ffj_t_MessageFromBot_TelegramInlineConfig

	ffj_t_MessageFromBot_TelegramCallbackAnswer

	ffj_t_MessageFromBot_TelegramEditMessageText

	ffj_t_MessageFromBot_TelegramEditMessageMarkup

	ffj_t_MessageFromBot_TelegramChatID

	ffj_t_MessageFromBot_IsReplyToInputMessage
)

var ffj_key_MessageFromBot_Text = []byte("Text")

var ffj_key_MessageFromBot_Format = []byte("Format")

var ffj_key_MessageFromBot_DisableWebPagePreview = []byte("DisableWebPagePreview")

var ffj_key_MessageFromBot_DisableNotification = []byte("DisableNotification")

var ffj_key_MessageFromBot_TelegramKeyboard = []byte("TelegramKeyboard")

var ffj_key_MessageFromBot_ViberKeyboard = []byte("ViberKeyboard")

var ffj_key_MessageFromBot_FbmAttachment = []byte("FbmAttachment")

var ffj_key_MessageFromBot_TelegramInlineConfig = []byte("TelegramInlineConfig")

var ffj_key_MessageFromBot_TelegramCallbackAnswer = []byte("TelegramCallbackAnswer")

var ffj_key_MessageFromBot_TelegramEditMessageText = []byte("TelegramEditMessageText")

var ffj_key_MessageFromBot_TelegramEditMessageMarkup = []byte("TelegramEditMessageMarkup")

var ffj_key_MessageFromBot_TelegramChatID = []byte("TelegramChatID")

var ffj_key_MessageFromBot_IsReplyToInputMessage = []byte("IsReplyToInputMessage")

func (uj *MessageFromBot) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MessageFromBot) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MessageFromBotbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MessageFromBotno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'D':

					if bytes.Equal(ffj_key_MessageFromBot_DisableWebPagePreview, kn) {
						currentKey = ffj_t_MessageFromBot_DisableWebPagePreview
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MessageFromBot_DisableNotification, kn) {
						currentKey = ffj_t_MessageFromBot_DisableNotification
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'F':

					if bytes.Equal(ffj_key_MessageFromBot_Format, kn) {
						currentKey = ffj_t_MessageFromBot_Format
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MessageFromBot_FbmAttachment, kn) {
						currentKey = ffj_t_MessageFromBot_FbmAttachment
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'I':

					if bytes.Equal(ffj_key_MessageFromBot_IsReplyToInputMessage, kn) {
						currentKey = ffj_t_MessageFromBot_IsReplyToInputMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffj_key_MessageFromBot_Text, kn) {
						currentKey = ffj_t_MessageFromBot_Text
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MessageFromBot_TelegramKeyboard, kn) {
						currentKey = ffj_t_MessageFromBot_TelegramKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MessageFromBot_TelegramInlineConfig, kn) {
						currentKey = ffj_t_MessageFromBot_TelegramInlineConfig
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MessageFromBot_TelegramCallbackAnswer, kn) {
						currentKey = ffj_t_MessageFromBot_TelegramCallbackAnswer
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MessageFromBot_TelegramEditMessageText, kn) {
						currentKey = ffj_t_MessageFromBot_TelegramEditMessageText
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MessageFromBot_TelegramEditMessageMarkup, kn) {
						currentKey = ffj_t_MessageFromBot_TelegramEditMessageMarkup
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MessageFromBot_TelegramChatID, kn) {
						currentKey = ffj_t_MessageFromBot_TelegramChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'V':

					if bytes.Equal(ffj_key_MessageFromBot_ViberKeyboard, kn) {
						currentKey = ffj_t_MessageFromBot_ViberKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_MessageFromBot_IsReplyToInputMessage, kn) {
					currentKey = ffj_t_MessageFromBot_IsReplyToInputMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageFromBot_TelegramChatID, kn) {
					currentKey = ffj_t_MessageFromBot_TelegramChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MessageFromBot_TelegramEditMessageMarkup, kn) {
					currentKey = ffj_t_MessageFromBot_TelegramEditMessageMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MessageFromBot_TelegramEditMessageText, kn) {
					currentKey = ffj_t_MessageFromBot_TelegramEditMessageText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MessageFromBot_TelegramCallbackAnswer, kn) {
					currentKey = ffj_t_MessageFromBot_TelegramCallbackAnswer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageFromBot_TelegramInlineConfig, kn) {
					currentKey = ffj_t_MessageFromBot_TelegramInlineConfig
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageFromBot_FbmAttachment, kn) {
					currentKey = ffj_t_MessageFromBot_FbmAttachment
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MessageFromBot_ViberKeyboard, kn) {
					currentKey = ffj_t_MessageFromBot_ViberKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MessageFromBot_TelegramKeyboard, kn) {
					currentKey = ffj_t_MessageFromBot_TelegramKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MessageFromBot_DisableNotification, kn) {
					currentKey = ffj_t_MessageFromBot_DisableNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MessageFromBot_DisableWebPagePreview, kn) {
					currentKey = ffj_t_MessageFromBot_DisableWebPagePreview
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageFromBot_Format, kn) {
					currentKey = ffj_t_MessageFromBot_Format
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageFromBot_Text, kn) {
					currentKey = ffj_t_MessageFromBot_Text
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MessageFromBotno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MessageFromBot_Text:
					goto handle_Text

				case ffj_t_MessageFromBot_Format:
					goto handle_Format

				case ffj_t_MessageFromBot_DisableWebPagePreview:
					goto handle_DisableWebPagePreview

				case ffj_t_MessageFromBot_DisableNotification:
					goto handle_DisableNotification

				case ffj_t_MessageFromBot_TelegramKeyboard:
					goto handle_TelegramKeyboard

				case ffj_t_MessageFromBot_ViberKeyboard:
					goto handle_ViberKeyboard

				case ffj_t_MessageFromBot_FbmAttachment:
					goto handle_FbmAttachment

				case ffj_t_MessageFromBot_TelegramInlineConfig:
					goto handle_TelegramInlineConfig

				case ffj_t_MessageFromBot_TelegramCallbackAnswer:
					goto handle_TelegramCallbackAnswer

				case ffj_t_MessageFromBot_TelegramEditMessageText:
					goto handle_TelegramEditMessageText

				case ffj_t_MessageFromBot_TelegramEditMessageMarkup:
					goto handle_TelegramEditMessageMarkup

				case ffj_t_MessageFromBot_TelegramChatID:
					goto handle_TelegramChatID

				case ffj_t_MessageFromBot_IsReplyToInputMessage:
					goto handle_IsReplyToInputMessage

				case ffj_t_MessageFromBotno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Text:

	/* handler: uj.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Format:

	/* handler: uj.Format type=bots.MessageFormat kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for MessageFormat", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Format = MessageFormat(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableWebPagePreview:

	/* handler: uj.DisableWebPagePreview type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.DisableWebPagePreview = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.DisableWebPagePreview = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableNotification:

	/* handler: uj.DisableNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.DisableNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.DisableNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TelegramKeyboard:

	/* handler: uj.TelegramKeyboard type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.TelegramKeyboard)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ViberKeyboard:

	/* handler: uj.ViberKeyboard type=viberinterface.Keyboard kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ViberKeyboard = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ViberKeyboard == nil {
			uj.ViberKeyboard = new(viberinterface.Keyboard)
		}

		err = uj.ViberKeyboard.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FbmAttachment:

	/* handler: uj.FbmAttachment type=fbm_api.RequestAttachment kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.FbmAttachment = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.FbmAttachment == nil {
			uj.FbmAttachment = new(fbm_api.RequestAttachment)
		}

		err = uj.FbmAttachment.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TelegramInlineConfig:

	/* handler: uj.TelegramInlineConfig type=tgbotapi.InlineConfig kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.TelegramInlineConfig = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.TelegramInlineConfig == nil {
			uj.TelegramInlineConfig = new(tgbotapi.InlineConfig)
		}

		err = uj.TelegramInlineConfig.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TelegramCallbackAnswer:

	/* handler: uj.TelegramCallbackAnswer type=tgbotapi.CallbackConfig kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.TelegramCallbackAnswer = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.TelegramCallbackAnswer == nil {
			uj.TelegramCallbackAnswer = new(tgbotapi.AnswerCallbackQueryConfig)
		}

		err = uj.TelegramCallbackAnswer.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TelegramEditMessageText:

	/* handler: uj.TelegramEditMessageText type=tgbotapi.EditMessageTextConfig kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.TelegramEditMessageText = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.TelegramEditMessageText == nil {
			uj.TelegramEditMessageText = new(tgbotapi.EditMessageTextConfig)
		}

		err = uj.TelegramEditMessageText.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TelegramEditMessageMarkup:

	/* handler: uj.TelegramEditMessageMarkup type=tgbotapi.EditMessageReplyMarkupConfig kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.TelegramEditMessageMarkup = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.TelegramEditMessageMarkup == nil {
			uj.TelegramEditMessageMarkup = new(tgbotapi.EditMessageReplyMarkupConfig)
		}

		err = uj.TelegramEditMessageMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TelegramChatID:

	/* handler: uj.TelegramChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.TelegramChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsReplyToInputMessage:

	/* handler: uj.IsReplyToInputMessage type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.IsReplyToInputMessage = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.IsReplyToInputMessage = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
